#include <stdio.h>
void reverse_array(int array[], int start, int end)
{
    int temp;
    while(start<end)
    {
        temp = array[start];
        array[start] = array[end];
        array[end] = temp;
        start++;
        end--;
    }
}

void print_array(int array[],int size)
{
    for(int i=0;i<size;i++)
    {
        printf(" %d",array[i]);
    }
    printf("\n");
}


int main()
{
    int array[]={1,2,3,4,5,6,7,8,9,10};
    int n = sizeof(array) / sizeof(array[0]);
    print_array(array,n);
    reverse_array(array,0,n-1);
    print_array(array,n);
    reverse_array(array,0,n-1);
    print_array(array,n);
    

    return 0;
}












/* structure is used to return two values from minMax() */
#include<stdio.h>
struct pair
{
int min;
int max;
};

struct pair getMinMax(int arr[], int n)
{
struct pair minmax;	
int i;

/*If there is only one element then return it as min and max both*/
if (n == 1)
{
	minmax.max = arr[0];
	minmax.min = arr[0];	
	return minmax;
}

/* If there are more than one elements, then initialize min
	and max*/
if (arr[0] > arr[1])
{
	minmax.max = arr[0];
	minmax.min = arr[1];
}
else
{
	minmax.max = arr[1];
	minmax.min = arr[0];
}

for (i = 2; i<n; i++)
{
	if (arr[i] > minmax.max)	
	minmax.max = arr[i];

	else if (arr[i] < minmax.min)	
	minmax.min = arr[i];
}

return minmax;
}

/* Driver program to test above function */
int main()
{
int arr[] = {1000, 11, 445, 1, 3300, 3000};
int arr_size = 6;
struct pair minmax = getMinMax (arr, arr_size);
printf("Minimum element is %d", minmax.min);
printf(" Maximum element is %d", minmax.max);

}











// Simple C++ program to find k'th smallest element
#include <algorithm>
#include <iostream>
using namespace std;
  
// Function to return k'th smallest element in a given array
int kthSmallest(int arr[], int n, int k)
{
    // Sort the given array
    sort(arr, arr + n);
  
    // Return k'th element in the sorted array
    return arr[k - 1];
}
  
// Driver program to test above methods
int main()
{
    int arr[] = { 12, 3, 5, 7, 19 };
    int n = sizeof(arr) / sizeof(arr[0]), k = 2;
    cout << "K'th smallest element is " << kthSmallest(arr, n, k);
    return 0;
}





// C program to sort an array with 0, 1 and 2
// in a single pass
#include <stdio.h>

/* Function to swap *a and *b */
void swap(int* a, int* b);

// Sort the input array, the array is assumed to
// have values in {0, 1, 2}
void sort012(int a[], int arr_size)
{
	int lo = 0;
	int hi = arr_size - 1;
	int mid = 0;

	while (mid <= hi) {
		switch (a[mid]) {
		case 0:
			swap(&a[lo++], &a[mid++]);
			break;
		case 1:
			mid++;
			break;
		case 2:
			swap(&a[mid], &a[hi--]);
			break;
		}
	}
}

/* UTILITY FUNCTIONS */
void swap(int* a, int* b)
{
	int temp = *a;
	*a = *b;
	*b = temp;
}

/* Utility function to print array arr[] */
void printArray(int arr[], int arr_size)
{
	int i;
	for (i = 0; i < arr_size; i++)
		printf("%d ", arr[i]);
	printf("\n");
}

/* driver program to test */
int main()
{
	int arr[] = { 0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1 };
	int arr_size = sizeof(arr) / sizeof(arr[0]);
	int i;

	sort012(arr, arr_size);

	printf("array after segregation ");
	printArray(arr, arr_size);

	
	return 0;
}





// C++ implementation of the approach
#include <bits/stdc++.h>
using namespace std;

// Utility function to print the contents of an array
void printArr(int arr[], int n)
{
	for (int i = 0; i < n; i++)
		cout << arr[i] << " ";
}

// Function to sort the array of 0s, 1s and 2s
void sortArr(int arr[], int n)
{
	int i, cnt0 = 0, cnt1 = 0, cnt2 = 0;

	// Count the number of 0s, 1s and 2s in the array
	for (i = 0; i < n; i++) {
		switch (arr[i]) {
		case 0:
			cnt0++;
			break;
		case 1:
			cnt1++;
			break;
		case 2:
			cnt2++;
			break;
		}
	}

	// Update the array
	i = 0;

	// Store all the 0s in the beginning
	while (cnt0 > 0) {
		arr[i++] = 0;
		cnt0--;
	}

	// Then all the 1s
	while (cnt1 > 0) {
		arr[i++] = 1;
		cnt1--;
	}

	// Finally all the 2s
	while (cnt2 > 0) {
		arr[i++] = 2;
		cnt2--;
	}

	// Print the sorted array
	printArr(arr, n);
}

// Driver code
int main()
{
	int arr[] = { 0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1 };
	int n = sizeof(arr) / sizeof(int);

	sortArr(arr, n);

	return 0;
}




#include<bits/stdc++.h>
using namespace std;
 void rearrange(int arr[], int n)
 {
     int j = 0;
     for(int i=0;i<n;i++)
     {
         if(arr[i]<0)
         {
             if(i!=j)
             {
                 swap(arr[i],arr[j]);
                 j++;
             }
         }
     }
 }
 
 void printarray(int arr[], int n)
 {
     for(int i=0;i<n;i++)
     {
         printf("%d",arr[i]);
     }
 }

int main()
{
    int arr[]={1,-1,5,6,4,-1,-2,-22};
    int n = sizeof(arr)/sizeof(arr[0]);
    rearrange(arr, n);
    printarray(arr, n);

    return 0;
}





// C++ program of the above
// approach

#include <iostream>
using namespace std;

// Function to shift all the
// negative elements on left side
void shiftall(int arr[], int left,
			int right)
{

// Loop to iterate over the
// array from left to the right
while (left<=right)
{
	// Condition to check if the left
	// and the right elements are
	// negative
	if (arr[left] < 0 && arr[right] < 0)
	left+=1;
	
	// Condition to check if the left
	// pointer element is positive and
	// the right pointer element is negative
	else if (arr[left]>0 && arr[right]<0)
	{
	int temp=arr[left];
	arr[left]=arr[right];
	arr[right]=temp;
	left+=1;
	right-=1;
	}
	
	// Condition to check if both the
	// elements are positive
	else if (arr[left]>0 && arr[right] >0)
	right-=1;
	else{
	left += 1;
	right -= 1;
	}
}
}

// Function to print the array
void display(int arr[], int right){

// Loop to iterate over the element
// of the given array
for (int i=0;i<=right;++i){
	cout<<arr[i]<<" ";
}
cout<<endl;
}

// Driver Code
int main()
{
int arr[] = {-12, 11, -13, -5,
			6, -7, 5, -3, 11};
int arr_size = sizeof(arr) /
				sizeof(arr[0]);

// Function Call
shiftall(arr,0,arr_size-1);
display(arr,arr_size-1);
return 0;
}

//added by Dhruv Goyal






// C program to find union of
// two sorted arrays
#include <stdio.h>

/* Function prints union of arr1[] and arr2[]
m is the number of elements in arr1[]
n is the number of elements in arr2[] */
void printUnion(int arr1[], int arr2[], int m, int n)
{
	int i = 0, j = 0;
	while (i < m && j < n) {
		if (arr1[i] < arr2[j])
			printf(" %d ", arr1[i++]);
		else if (arr2[j] < arr1[i])
			printf(" %d ", arr2[j++]);
		else {
			printf(" %d ", arr2[j++]);
			i++;
		}
	}

	/* Print remaining elements of the larger array */
	while (i < m)
		printf(" %d ", arr1[i++]);
	while (j < n)
		printf(" %d ", arr2[j++]);
}

/* Driver program to test above function */
int main()
{
	int arr1[] = { 1, 2, 4, 5, 6, 8};
	int arr2[] = { 2, 3, 5, 7 };
	int m = sizeof(arr1) / sizeof(arr1[0]);
	int n = sizeof(arr2) / sizeof(arr2[0]);
	printUnion(arr1, arr2, m, n);
	
	return 0;
}




// C program to find union of
// two sorted arrays
#include <stdio.h>

/* Function prints union of arr1[] and arr2[]
m is the number of elements in arr1[]
n is the number of elements in arr2[] */
void printUnion(int arr1[], int arr2[], int m, int n)
{
	int i = 0, j = 0;
	while (i < m && j < n) {
		if (arr1[i] < arr2[j])
			printf(" %d ", arr1[i++]);
		else if (arr2[j] < arr1[i])
			printf(" %d ", arr2[j++]);
		else {
			printf(" %d ", arr2[j++]);
			i++;
		}
	}

	/* Print remaining elements of the larger array */
	while (i < m)
		printf(" %d ", arr1[i++]);
	while (j < n)
		printf(" %d ", arr2[j++]);
		printf("\n");
}


// C program to find intersection of
// two sorted arrays
#include <stdio.h>
 
/* Function prints Intersection of arr1[] and arr2[]
   m is the number of elements in arr1[]
   n is the number of elements in arr2[] */
void printIntersection(int arr1[], int arr2[], int m, int n)
{
    int i = 0, j = 0;
    while (i < m && j < n) {
        if (arr1[i] < arr2[j])
            i++;
        else if (arr2[j] < arr1[i])
            j++;
        else /* if arr1[i] == arr2[j] */
        {
            printf(" %d ", arr2[j++]);
            i++;
        }
    }
}
/* Driver program to test above function */
int main()
{
	int arr1[] = { 1, 2, 4, 5, 6, 8};
	int arr2[] = { 2, 3, 5, 7 };
	int m = sizeof(arr1) / sizeof(arr1[0]);
	int n = sizeof(arr2) / sizeof(arr2[0]);
	printUnion(arr1, arr2, m, n);
	printIntersection(arr1, arr2, m, n);
	
	return 0;
}




#include <stdio.h>

void rotate(int arr[], int n)
{
int x = arr[n-1], i;
for (i = n-1; i > 0; i--)
	arr[i] = arr[i-1];
arr[0] = x;
}

int main()
{
	int arr[] = {1, 2, 3, 4, 5}, i;
	int n = sizeof(arr)/sizeof(arr[0]);

	printf("Given array is\n");
	for (i = 0; i < n; i++)
		printf("%d ", arr[i]);

	rotate(arr, n);

	printf("\nRotated array is\n");
	for (i = 0; i < n; i++)
		printf("%d ", arr[i]);

	return 0;
}




#include<iostream>
#include<climits>
using namespace std;

int maxsubarraysum(int a[], int size)
{
    int max_so_far=INT_MIN, max_ending_here=0;
    for(int i=0; i<size;i++)
    {
        max_ending_here = max_ending_here + a[i];
        if(max_so_far<max_ending_here)
           max_so_far=max_ending_here;
           
        if(max_ending_here<0)
          max_ending_here=0;
    }
    return max_so_far;
}

int main()
{
    	int a[] = {-2, -3, 4, -1, -2, 1, 5, -3, 9};
	int n = sizeof(a)/sizeof(a[0]);
	int max_sum = maxsubarraysum(a, n);
	cout << "Maximum contiguous sum is " << max_sum;
	return 0;
}
    




// C++ program to merge two sorted
// arrays with O(1) extra space.
#include <bits/stdc++.h>
using namespace std;

// Merge ar1[] and ar2[] with O(1) extra space
void merge(int ar1[], int ar2[], int m, int n)
{
	// Iterate through all elements
	// of ar2[] starting from the last element
	for (int i = n - 1; i >= 0; i--)
	{
		/* Find the smallest element greater than ar2[i].
		Move all elements one position ahead till the
		smallest greater element is not found */
		int j, last = ar1[m - 1];
		for (j = m - 2; j >= 0 && ar1[j] > ar2[i]; j--)
		{	ar1[j + 1] = ar1[j];}

		// If there was a greater element
		if (j != m - 2 || last > ar2[i])
		{
			ar1[j + 1] = ar2[i];
			ar2[i] = last;
		}
	}
}

// Driver program
int main()
{
	int ar1[] = { 1, 5, 9, 10, 15, 20, 54 };
	int ar2[] = { 2, 3, 8, 12, 32 };
	int m = sizeof(ar1) / sizeof(ar1[0]);
	int n = sizeof(ar2) / sizeof(ar2[0]);
	merge(ar1, ar2, m, n);

	cout << "After Merging nFirst Array: ";
	for (int i = 0; i < m; i++)
		cout << ar1[i] << " ";
	cout << "Second Array: ";
	for (int i = 0; i < n; i++)
		cout << ar2[i] << " ";
	return 0;
}



// CPP program for the above approach
#include <bits/stdc++.h>
using namespace std;

// Function to merge two arrays
void merge(int arr1[], int arr2[], int n, int m)
{
	int i = 0, j = 0, k = n - 1;

	// Until i less than equal to k
	// or j is less tha m
	while (i <= k && j < m) {
		if (arr1[i] < arr2[j])
			i++;
		else {
			swap(arr2[j++], arr1[k--]);
		}
	}

	// Sort first array
	sort(arr1, arr1 + n);

	// Sort second array
	sort(arr2, arr2 + m);
}

// Driver Code
int main()
{

	int ar1[] = { 1, 5, 9, 10, 15, 20 };
	int ar2[] = { 2, 3, 8, 13 };
	int m = sizeof(ar1) / sizeof(ar1[0]);
	int n = sizeof(ar2) / sizeof(ar2[0]);
	merge(ar1, ar2, m, n);

	cout << "After Merging \nFirst Array: ";
	for (int i = 0; i < m; i++)
		cout << ar1[i] << " ";
	cout << "\nSecond Array: ";
	for (int i = 0; i < n; i++)
		cout << ar2[i] << " ";
	return 0;
}






    var max = 0;
    var sum = 0;
    
    for (int i = 0; i < prices.Length - 1; i++)
    {
        sum += prices[i + 1] - prices[i];
        
        if (sum > max)
        {
            max = sum;
        }
        else if (sum < 0)
        {
            sum = 0;
        }
    }
    
    return max;
}















// C++ program to print common elements in three arrays
#include <bits/stdc++.h>
using namespace std;

// This function prints common elements in ar1
void findCommon(int ar1[], int ar2[], int ar3[], int n1, int n2, int n3)
{
	// Initialize starting indexes for ar1[], ar2[] and ar3[]
	int i = 0, j = 0, k = 0;

	// Iterate through three arrays while all arrays have elements
	while (i < n1 && j < n2 && k < n3)
	{
		// If x = y and y = z, print any of them and move ahead
		// in all arrays
		if (ar1[i] == ar2[j] && ar2[j] == ar3[k])
		{ cout << ar1[i] << " "; i++; j++; k++; }

		// x < y
		else if (ar1[i] < ar2[j])
			i++;

		// y < z
		else if (ar2[j] < ar3[k])
			j++;

		// We reach here when x > y and z < y, i.e., z is smallest
		else
			k++;
	}
}

// Driver code
int main()
{
	int ar1[] = {1, 5, 10, 20, 40, 80, 100};
	int ar2[] = {6, 7, 20, 80, 100};
	int ar3[] = {3, 4, 15, 20, 30, 70, 80, 100, 120};
	int n1 = sizeof(ar1)/sizeof(ar1[0]);
	int n2 = sizeof(ar2)/sizeof(ar2[0]);
	int n3 = sizeof(ar3)/sizeof(ar3[0]);

	cout << "Common Elements are ";
	findCommon(ar1, ar2, ar3, n1, n2, n3);
	return 0;
}
















// C++ program to print common
// elements in three arrays
#include <bits/stdc++.h>
using namespace std;

// This function prints
// common elements in ar1
void findCommon(int ar1[], int ar2[], int ar3[], int n1,
				int n2, int n3)
{
	
	// Initialize starting indexes
	// for ar1[], ar2[] and
	// ar3[]
	int i = 0, j = 0, k = 0;

	// Declare three variables prev1,
	// prev2, prev3 to track
	// previous element
	int prev1, prev2, prev3;

	// Initialize prev1, prev2,
	// prev3 with INT_MIN
	prev1 = prev2 = prev3 = INT_MIN;

	// Iterate through three arrays
	// while all arrays have
	// elements
	while (i < n1 && j < n2 && k < n3) {
		
		// If ar1[i] = prev1 and i < n1,
		// keep incrementing i
		while (ar1[i] == prev1 && i < n1)
			i++;

		// If ar2[j] = prev2 and j < n2,
		// keep incrementing j
		while (ar2[j] == prev2 && j < n2)
			j++;

		// If ar3[k] = prev3 and k < n3,
		// keep incrementing k
		while (ar3[k] == prev3 && k < n3)
			k++;

		// If x = y and y = z, print
		// any of them, update
		// prev1 prev2, prev3 and move
		//ahead in each array
		if (ar1[i] == ar2[j] && ar2[j] == ar3[k]) {
			cout << ar1[i] << " ";
			prev1 = ar1[i];
			prev2 = ar2[j];
			prev3 = ar3[k];
			i++;
			j++;
			k++;
		}

		// If x < y, update prev1
		// and increment i
		else if (ar1[i] < ar2[j]) {
			prev1 = ar1[i];
			i++;
		}

		// If y < z, update prev2
		// and increment j
		else if (ar2[j] < ar3[k]) {
			prev2 = ar2[j];
			j++;
		}

		// We reach here when x > y
		// and z < y, i.e., z is
		// smallest update prev3
		// and imcrement k
		else {
			prev3 = ar3[k];
			k++;
		}
	}
}

// Driver code
int main()
{
	int ar1[] = { 1, 5, 10, 20, 40, 80, 80 };
	int ar2[] = { 6, 7, 20, 80, 80, 100 };
	int ar3[] = { 3, 4, 15, 20, 30, 70, 80, 80, 120 };
	int n1 = sizeof(ar1) / sizeof(ar1[0]);
	int n2 = sizeof(ar2) / sizeof(ar2[0]);
	int n3 = sizeof(ar3) / sizeof(ar3[0]);

	cout << "Common Elements are ";
	findCommon(ar1, ar2, ar3, n1, n2, n3);
	return 0;
}



















// C++ implementation of simple method to find count of
// pairs with given sum.
#include <bits/stdc++.h>
using namespace std;

// Returns number of pairs in arr[0..n-1] with sum equal
// to 'sum'
int getPairsCount(int arr[], int n, int sum)
{
	int count = 0; // Initialize result

	// Consider all possible pairs and check their sums
	for (int i = 0; i < n; i++)
		for (int j = i + 1; j < n; j++)
			if (arr[i] + arr[j] == sum)
				count++;

	return count;
}

// Driver function to test the above function
int main()
{
	int arr[] = { 1, 5, 7, -1, 5 };
	int n = sizeof(arr) / sizeof(arr[0]);
	int sum = 6;
	cout << "Count of pairs is "
		<< getPairsCount(arr, n, sum);
	return 0;
}








// A C++ program to find if
// there is a zero sum subarray
#include <bits/stdc++.h>
using namespace std;

bool subArrayExists(int arr[], int n)
{
	unordered_set<int> sumSet;

	// Traverse through array
	// and store prefix sums
	int sum = 0;
	for (int i = 0; i < n; i++)
	{
		sum += arr[i];

		// If prefix sum is 0 or
		// it is already present
		if (sum == 0
			|| sumSet.find(sum)
			!= sumSet.end())
			return true;

		sumSet.insert(sum);
	}
	return false;
}

// Driver code
int main()
{
	int arr[] = { -3, 2, 1, 1, 6 };
	int n = sizeof(arr) / sizeof(arr[0]);
	if (subArrayExists(arr, n))
		cout << "Found a subarray with 0 sum";
	else
		cout << "No Such Sub Array Exists!";
	return 0;
}













// C++ program to compute factorial of big numbers
#include<iostream>
using namespace std;

// Maximum number of digits in output
#define MAX 500

int multiply(int x, int res[], int res_size);

// This function finds factorial of large numbers
// and prints them
void factorial(int n)
{
	int res[MAX];

	// Initialize result
	res[0] = 1;
	int res_size = 1;

	// Apply simple factorial formula n! = 1 * 2 * 3 * 4...*n
	for (int x=2; x<=n; x++)
		res_size = multiply(x, res, res_size);

	cout << "Factorial of given number is \n";
	for (int i=res_size-1; i>=0; i--)
		cout << res[i];
}

// This function multiplies x with the number
// represented by res[].
// res_size is size of res[] or number of digits in the
// number represented by res[]. This function uses simple
// school mathematics for multiplication.
// This function may value of res_size and returns the
// new value of res_size
int multiply(int x, int res[], int res_size)
{
	int carry = 0; // Initialize carry

	// One by one multiply n with individual digits of res[]
	for (int i=0; i<res_size; i++)
	{
		int prod = res[i] * x + carry;

		// Store last digit of 'prod' in res[]
		res[i] = prod % 10;

		// Put rest in carry
		carry = prod/10;
	}

	// Put carry in res and increase result size
	while (carry)
	{
		res[res_size] = carry%10;
		carry = carry/10;
		res_size++;
	}
	return res_size;
}

// Driver program
int main()
{
	factorial(200);
	return 0;
}










// C++ program to find Maximum Product Subarray
#include <bits/stdc++.h>
using namespace std;

/* Returns the product of max product subarray.*/
int maxSubarrayProduct(int arr[], int n)
{
	// Initializing result
	int result = arr[0];

	for (int i = 0; i < n; i++)
	{
		int mul = arr[i];
		// traversing in current subarray
		for (int j = i + 1; j < n; j++)
		{
			// updating result every time
			// to keep an eye over the maximum product
			result = max(result, mul);
			mul *= arr[j];
		}
		// updating the result for (n-1)th index.
		result = max(result, mul);
	}
	return result;
}

// Driver code
int main()
{
	int arr[] = { 1, -2, -3, 0, 7, -8, -2 };
	int n = sizeof(arr) / sizeof(arr[0]);
	cout << "Maximum Sub array product is "
		<< maxSubarrayProduct(arr, n);
	return 0;
}

// This code is contributed by yashbeersingh42








// A C++ program to print elements with count more than n/k
#include <iostream>
using namespace std;

// A structure to store an element and its current count
struct eleCount {
	int e; // Element
	int c; // Count
};

// Prints elements with more
// than n/k occurrences in arr[]
// of size n. If there are no
// such elements, then it prints
// nothing.
void moreThanNdK(int arr[], int n, int k)
{
	// k must be greater than
	// 1 to get some output
	if (k < 2)
		return;

	/* Step 1: Create a temporary
	array (contains element
	and count) of size k-1.
	Initialize count of all
	elements as 0 */
	struct eleCount temp[k - 1];
	for (int i = 0; i < k - 1; i++)
		temp[i].c = 0;

	/* Step 2: Process all
	elements of input array */
	for (int i = 0; i < n; i++)
	{
		int j;

		/* If arr[i] is already present in
		the element count array,
		then increment its count
		*/
		for (j = 0; j < k - 1; j++)
		{
			if (temp[j].e == arr[i])
			{
				temp[j].c += 1;
				break;
			}
		}

		/* If arr[i] is not present in temp[] */
		if (j == k - 1) {
			int l;

			/* If there is position available
			in temp[], then place arr[i] in
			the first available position and
			set count as 1*/
			for (l = 0; l < k - 1; l++)
			{
				if (temp[l].c == 0)
				{
					temp[l].e = arr[i];
					temp[l].c = 1;
					break;
				}
			}

			/* If all the position in the
			temp[] are filled, then decrease
			count of every element by 1 */
			if (l == k - 1)
				for (l = 0; l < k-1; l++)
					temp[l].c -= 1;
		}
	}

	/*Step 3: Check actual counts of
	* potential candidates in temp[]*/
	for (int i = 0; i < k - 1; i++)
	{
		// Calculate actual count of elements
		int ac = 0; // actual count
		for (int j = 0; j < n; j++)
			if (arr[j] == temp[i].e)
				ac++;

		// If actual count is more than n/k,
	// then print it
		if (ac > n / k)
			cout << "Number:" << temp[i].e
				<< " Count:" << ac << endl;
	}
}

/* Driver code */
int main()
{
	cout << "First Test\n";
	int arr1[] = { 4, 5, 6, 7, 8, 4, 4 };
	int size = sizeof(arr1) / sizeof(arr1[0]);
	int k = 3;
	moreThanNdK(arr1, size, k);

	cout << "\nSecond Test\n";
	int arr2[] = { 4, 2, 2, 7 };
	size = sizeof(arr2) / sizeof(arr2[0]);
	k = 3;
	moreThanNdK(arr2, size, k);

	cout << "\nThird Test\n";
	int arr3[] = { 2, 7, 2 };
	size = sizeof(arr3) / sizeof(arr3[0]);
	k = 2;
	moreThanNdK(arr3, size, k);

	cout << "\nFourth Test\n";
	int arr4[] = { 2, 3, 3, 2 };
	size = sizeof(arr4) / sizeof(arr4[0]);
	k = 3;
	moreThanNdK(arr4, size, k);

	return 0;
}







// C++ code to find elements whose
// frequency yis more than n/k
#include<bits/stdc++.h>
using namespace std;

void morethanNbyK(int arr[], int n, int k)
{
	int x = n / k;
	
	// unordered_map initialization
	unordered_map<int, int> freq;

	for(int i = 0; i < n; i++)
	{
		freq[arr[i]]++;
	}

	// Traversing the map
	for(auto i : freq)
	{
		
		// Checking if value of a key-value pair
		// is greater than x (where x=n/k)
		if (i.second > x)
		{
			
			// Print the key of whose value
			// is greater than x
			cout << i.first << endl;
		}
	}
}

// Driver Code
int main()
{
	int arr[] = { 1, 1, 2, 2, 3, 5,
				4, 2, 2, 3, 1, 1, 1 };
	int n = sizeof(arr) / sizeof(arr[0]);
	int k = 4;
	
	morethanNbyK(arr, n, k);

	return 0;
}

// This code is contributed by chayandas018













// C++ implementation
#include <bits/stdc++.h>
using namespace std;

// Function to find the number of array
// elements with frequency more than n/k times
void printElements(int arr[], int n, int k)
{

	// Calculating n/k
	int x = n / k;

	// Counting frequency of every
	// element using Counter
	map<int, int> mp;
	for (int i = 0; i < n; i++)
		mp[arr[i]] += 1;

	// Traverse the map and print all
	// the elements with occurrence
	// more than n/k times
	for (int it = 0; it < mp.size(); it++) {
		if (mp[it] > x)
			cout << (it) << endl;
	}
}

// Driver code
int main()
{
	int arr[] = { 1, 1, 2, 2, 3, 5, 4, 2, 2, 3, 1, 1, 1 };
	int n = sizeof(arr) / sizeof(arr[0]);
	int k = 4;

	printElements(arr, n, k);
}

// This code is contributed by ukasp.














// C++ program to find whether an array
// is subset of another array
#include <bits/stdc++.h>

/* Return 1 if arr2[] is a subset of
arr1[] */
bool isSubset(int arr1[], int arr2[],
			int m, int n)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < n; i++) {
		for (j = 0; j < m; j++) {
			if (arr2[i] == arr1[j])
				break;
		}

		/* If the above inner loop was
		not broken at all then arr2[i]
		is not present in arr1[] */
		if (j == m)
			return 0;
	}

	/* If we reach here then all
	elements of arr2[] are present
	in arr1[] */
	return 1;
}

// Driver code
int main()
{
	int arr1[] = { 11, 1, 13, 21, 3, 7 };
	int arr2[] = { 11, 3, 7, 1 ,21};

	int m = sizeof(arr1) / sizeof(arr1[0]);
	int n = sizeof(arr2) / sizeof(arr2[0]);

	if (isSubset(arr1, arr2, m, n))
		printf("arr2[] is subset of arr1[] ");
	else
		printf("arr2[] is not a subset of arr1[]");

	
	return 0;
}









// C program to find whether an array
// is subset of another array
#include <stdbool.h>
#include <stdio.h>
/* Function prototypes */
void quickSort(int* arr, int si, int ei);
int binarySearch(int arr[], int low,
				int high, int x);

/* Return 1 if arr2[] is a subset of arr1[] */
bool isSubset(int arr1[], int arr2[],
			int m, int n)
{
	int i = 0;

	quickSort(arr1, 0, m - 1);
	for (i = 0; i < n; i++) {
		if (binarySearch(arr1, 0, m - 1,
						arr2[i]) == -1)
			return 0;
	}

	/* If we reach here then all elements of arr2[]
	are present in arr1[] */
	return 1;
}

/* FOLLOWING FUNCTIONS ARE ONLY FOR SEARCHING
AND SORTING PURPOSE */
/* Standard Binary Search function*/
int binarySearch(int arr[], int low, int high, int x)
{
	if (high >= low)
	{
		/*low + (high - low)/2;*/
		int mid = (low + high) / 2;

		/* Check if arr[mid] is the first
		occurrence of x.
		arr[mid] is first occurrence if x is
		one of the following
		is true:
		(i) mid == 0 and arr[mid] == x
		(ii) arr[mid-1] < x and arr[mid] == x
	*/
		if ((mid == 0 || x > arr[mid - 1]) && (arr[mid] == x))
			return mid;
		else if (x > arr[mid])
			return binarySearch(arr, (mid + 1), high, x);
		else
			return binarySearch(arr, low, (mid - 1), x);
	}
	return -1;
}

void exchange(int* a, int* b)
{
	int temp;
	temp = *a;
	*a = *b;
	*b = temp;
}

int partition(int A[], int si, int ei)
{
	int x = A[ei];
	int i = (si - 1);
	int j;

	for (j = si; j <= ei - 1; j++) {
		if (A[j] <= x) {
			i++;
			exchange(&A[i], &A[j]);
		}
	}
	exchange(&A[i + 1], &A[ei]);
	return (i + 1);
}

/* Implementation of Quick Sort
A[] --> Array to be sorted
si --> Starting index
ei --> Ending index
*/
void quickSort(int A[], int si, int ei)
{
	int pi; /* Partitioning index */
	if (si < ei) {
		pi = partition(A, si, ei);
		quickSort(A, si, pi - 1);
		quickSort(A, pi + 1, ei);
	}
}

/*Driver code */
int main()
{
	int arr1[] = { 11, 1, 13, 21, 3, 7 };
	int arr2[] = { 11, 3, 7, 1 };

	int m = sizeof(arr1) / sizeof(arr1[0]);
	int n = sizeof(arr2) / sizeof(arr2[0]);

	if (isSubset(arr1, arr2, m, n))
		printf("arr2[] is subset of arr1[] ");
	else
		printf("arr2[] is not a subset of arr1[] ");

	return 0;
}








#include <stdio.h>

// returns true if there is triplet with sum equal
// to 'sum' present in A[]. Also, prints the triplet
bool find3Numbers(int A[], int arr_size, int sum)
{
	int l, r;

	// Fix the first element as A[i]
	for (int i = 0; i < arr_size - 2; i++) {

		// Fix the second element as A[j]
		for (int j = i + 1; j < arr_size - 1; j++) {

			// Now look for the third number
			for (int k = j + 1; k < arr_size; k++) {
				if (A[i] + A[j] + A[k] == sum) {
					printf("Triplet is %d, %d, %d",
						A[i], A[j], A[k]);
					return true;
				}
			}
		}
	}

	// If we reach here, then no triplet was found
	return false;
}

/* Driver program to test above function */
int main()
{
	int A[] = { 1, 4, 45, 6, 10, 8 };
	int sum = 22;
	int arr_size = sizeof(A) / sizeof(A[0]);
	find3Numbers(A, arr_size, sum);
	return 0;
}






// C++ program to find a triplet
#include <bits/stdc++.h>
using namespace std;

// returns true if there is triplet with sum equal
// to 'sum' present in A[]. Also, prints the triplet
bool find3Numbers(int A[], int arr_size, int sum)
{
	int l, r;

	/* Sort the elements */
	sort(A, A + arr_size);

	/* Now fix the first element one by one and find the
	other two elements */
	for (int i = 0; i < arr_size - 2; i++) {

		// To find the other two elements, start two index
		// variables from two corners of the array and move
		// them toward each other
		l = i + 1; // index of the first element in the
		// remaining elements

		r = arr_size - 1; // index of the last element
		while (l < r) {
			if (A[i] + A[l] + A[r] == sum) {
				printf("Triplet is %d, %d, %d", A[i],
					A[l], A[r]);
				return true;
			}
			else if (A[i] + A[l] + A[r] < sum)
				l++;
			else  (A[i] + A[l] + A[r] > sum);
				r--;
		}
	}

	// If we reach here, then no triplet was found
	return false;
}

/* Driver program to test above function */
int main()
{
	int A[] = { 1, 4, 45, 6, 10, 8, -5 };
	int sum = 0;
	int arr_size = sizeof(A) / sizeof(A[0]);

	find3Numbers(A, arr_size, sum);

	return 0;
}







// C++ implementation of the approach
#include<bits/stdc++.h>
using namespace std;

// Function to return the maximum
// water that can be stored
int maxWater(int arr[], int n)
{
	
	// To store the maximum water
	// that can be stored
	int res = 0;
	
	// For every element of the array
	for (int i = 1; i < n-1; i++) {
		
		// Find the maximum element on its left
		int left = arr[i];
		for (int j=0; j<i; j++)
		left = max(left, arr[j]);
		
		// Find the maximum element on its right
		int right = arr[i];
		for (int j=i+1; j<n; j++)
		right = max(right, arr[j]);
		
	// Update the maximum water
	res = res + (min(left, right) - arr[i]);
	}

	return res;
}

// Driver code
int main()
{
	int arr[] = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
	int n = sizeof(arr)/sizeof(arr[0]);
	
	cout << maxWater(arr, n);
	
	return 0;
}









// C++ program to find maximum amount of water that can
// be trapped within given set of bars.
#include <bits/stdc++.h>
using namespace std;

int findWater(int arr[], int n)
{
	// left[i] contains height of tallest bar to the
	// left of i'th bar including itself
	int left[n];

	// Right [i] contains height of tallest bar to
	// the right of ith bar including itself
	int right[n];

	// Initialize result
	int water = 0;

	// Fill left array
	left[0] = arr[0];
	for (int i = 1; i < n; i++)
		left[i] = max(left[i - 1], arr[i]);

	// Fill right array
	right[n - 1] = arr[n - 1];
	for (int i = n - 2; i >= 0; i--)
		right[i] = max(right[i + 1], arr[i]);

	// Calculate the accumulated water element by element
	// consider the amount of water on i'th bar, the
	// amount of water accumulated on this particular
	// bar will be equal to min(left[i], right[i]) - arr[i] .
	for (int i = 0; i < n; i++)
		water += min(left[i], right[i]) - arr[i];

	return water;
}

// Driver program
int main()
{
	int arr[] = { 10, 0, 10, 0, 10};
	int n = sizeof(arr) / sizeof(arr[0]);
	cout << "Maximum water that can be accumulated is "
		<< findWater(arr, n);
	return 0;
}















// C++ program to solve chocolate distribution
// problem
#include <bits/stdc++.h>
using namespace std;

// arr[0..n-1] represents sizes of packets
// m is number of students.
// Returns minimum difference between maximum
// and minimum values of distribution.
int findMinDiff(int arr[], int n, int m)
{
	// if there are no chocolates or number
	// of students is 0
	if (m == 0 || n == 0)
		return 0;

	// Sort the given packets
	sort(arr, arr + n);

	// Number of students cannot be more than
	// number of packets
	if (n < m)
		return -1;

	// Largest number of chocolates
	int min_diff = INT_MAX;

	// Find the subarray of size m such that
	// difference between last (maximum in case
	// of sorted) and first (minimum in case of
	// sorted) elements of subarray is minimum.

	for (int i = 0; i + m - 1 < n; i++) {
		int diff = arr[i + m - 1] - arr[i];
		if (diff < min_diff)
			min_diff = diff;
	}
	return min_diff;
}

int main()
{
	int arr[] = { 12, 4, 7, 9, 2, 23, 25, 41, 30,
				40, 28, 42, 30, 44, 48, 43, 50 };
	int m = 7; // Number of students
	int n = sizeof(arr) / sizeof(arr[0]);
	cout << "Minimum difference is "
		<< findMinDiff(arr, n, m);
	return 0;
}













# include <iostream>
using namespace std;

// Returns length of smallest subarray with sum greater than x.
// If there is no subarray with given sum, then returns n+1
int smallestSubWithSum(int arr[], int n, int x)
{
	// Initialize length of smallest subarray as n+1
	int min_len = n + 1;

	// Pick every element as starting point
	for (int start=0; start<n; start++)
	{
		// Initialize sum starting with current start
		int curr_sum = arr[start];

		// If first element itself is greater
		if (curr_sum > x) return 1;

		// Try different ending points for current start
		for (int end=start+1; end<n; end++)
		{
			// add last element to current sum
			curr_sum += arr[end];

			// If sum becomes more than x and length of
			// this subarray is smaller than current smallest
			// length, update the smallest length (or result)
			if (curr_sum > x && (end - start + 1) < min_len)
				min_len = (end - start + 1);
		}
	}
	return min_len;
}

/* Driver program to test above function */
int main()
{
	int arr1[] = {1, 4, 45, 6, 10, 19};
	int x = 51;
	int n1 = sizeof(arr1)/sizeof(arr1[0]);
	int res1 = smallestSubWithSum(arr1, n1, x);
	(res1 == n1+1)? cout << "Not possible\n" :
					cout << res1 << endl;

	int arr2[] = {1, 10, 5, 2, 7};
	int n2 = sizeof(arr2)/sizeof(arr2[0]);
	x = 9;
	int res2 = smallestSubWithSum(arr2, n2, x);
	(res2 == n2+1)? cout << "Not possible\n" :
					cout << res2 << endl;

	int arr3[] = {1, 11, 100, 1, 0, 200, 3, 2, 1, 250};
	int n3 = sizeof(arr3)/sizeof(arr3[0]);
	x = 280;
	int res3 = smallestSubWithSum(arr3, n3, x);
	(res3 == n3+1)? cout << "Not possible\n" :
					cout << res3 << endl;

	return 0;
}












// C++ program to implement three way partitioning
// around a given range.
#include<iostream>
using namespace std;

// Partitions arr[0..n-1] around [lowVal..highVal]
void threeWayPartition(int arr[], int n,
				int lowVal, int highVal)
{
	// Initialize ext available positions for
	// smaller (than range) and greater lements
	int start = 0, end = n-1;

	// Traverse elements from left
	for (int i=0; i<=end;)
	{
		// If current element is smaller than
		// range, put it on next available smaller
		// position.
		if (arr[i] < lowVal)
		{
		//if i and start are same in that case we can't swap
		//swap only if i is greater than start
		if(i==start)
		{
			start++;
			i++;
		}
		else
			swap(arr[i++], arr[start++]);
		}

		// If current element is greater than
		// range, put it on next available greater
		// position.
		else if (arr[i] > highVal)
			swap(arr[i], arr[end--]);

		else
			i++;
	}
}

// Driver code
int main()
{
	int arr[] = {1, 14, 5, 20, 4, 2, 54, 20, 87,
				98, 3, 1, 32};
	int n = sizeof(arr)/sizeof(arr[0]);

	threeWayPartition(arr, n, 10, 20);

	cout << "Modified array \n";
	for (int i=0; i<n; i++)
		cout << arr[i] << " ";
}




















// C++ program to find minimum swaps required
// to club all elements less than or equals
// to k together
#include <iostream>
using namespace std;

// Utility function to find minimum swaps
// required to club all elements less than
// or equals to k together
int minSwap(int *arr, int n, int k) {
	
	// Find count of elements which are
	// less than equals to k
	int count = 0;
	for (int i = 0; i < n; ++i)
		if (arr[i] <= k)
			++count;
	
	// Find unwanted elements in current
	// window of size 'count'
	int bad = 0;
	for (int i = 0; i < count; ++i)
		if (arr[i] > k)
			++bad;
	
	// Initialize answer with 'bad' value of
	// current window
	int ans = bad;
	for (int i = 0, j = count; j < n; ++i, ++j) {
		
		// Decrement count of previous window
		if (arr[i] > k)
			--bad;
		
		// Increment count of current window
		if (arr[j] > k)
			++bad;
		
		// Update ans if count of 'bad'
		// is less in current window
		ans = min(ans, bad);
	}
	return ans;
}

// Driver code
int main() {
	
	int arr[] = {2, 1, 5, 6, 3};
	int n = sizeof(arr) / sizeof(arr[0]);
	int k = 3;
	cout << minSwap(arr, n, k) << "\n";
	
	int arr1[] = {2, 7, 9, 5, 8, 7, 4};
	n = sizeof(arr1) / sizeof(arr1[0]);
	k = 5;
	cout << minSwap(arr1, n, k);
	return 0;
}










// C++ program to find number of operations
// to make an array palindrome
#include <bits/stdc++.h>
using namespace std;

// Returns minimum number of count operations
// required to make arr[] palindrome
int findMinOps(int arr[], int n)
{
	int ans = 0; // Initialize result

	// Start from two corners
	for (int i=0,j=n-1; i<=j;)
	{
		// If corner elements are same,
		// problem reduces arr[i+1..j-1]
		if (arr[i] == arr[j])
		{
			i++;
			j--;
		}

		// If left element is greater, then
		// we merge right two elements
		else if (arr[i] > arr[j])
		{
			// need to merge from tail.
			j--;
			arr[j] += arr[j+1] ;
			ans++;
		}

		// Else we merge left two elements
		else
		{
			i++;
			arr[i] += arr[i-1];
			ans++;
		}
	}

	return ans;
}

// Driver program to test above
int main()
{
	int arr[] = {1, 4, 5, 9, 1};
	int n = sizeof(arr)/sizeof(arr[0]);
	cout << "Count of minimum operations is "
		<< findMinOps(arr, n) << endl;
	return 0;
}









// C++ implementation of the above approach

#include <bits/stdc++.h>
using namespace std;

#define MAX 256

// Function to check whether elements of
// an array can form a palindrome
bool can_form_palindrome(int arr[], int n)
{
	// create an empty string
	// to append elements of an array
	string str = "";

	// append each element to the string str to form
	// a string so that we can solve it in easy way
	for (int i = 0; i < n; i++) {
		str += arr[i];
	}

	// Create a freq array and initialize all
	// values as 0
	int freq[MAX] = { 0 };

	// For each character in formed string,
	// increment freq in the corresponding
	// freq array
	for (int i = 0; str[i]; i++) {
		freq[str[i]]++;
	}
	int count = 0;

	// Count odd occurring characters
	for (int i = 0; i < MAX; i++) {
		if (freq[i] & 1) {
			count++;
		}
		if (count > 1) {
			return false;
		}
	}

	// Return true if odd count is 0 or 1,
	return true;
}
// Drive code
int main()
{
	int arr[] = { 1, 2, 1, 1, 3 };
	int n = sizeof(arr) / sizeof(int);
	can_form_palindrome(arr, n)
		? cout << "YES"
		: cout << "NO";
	return 0;
}






// A Simple Merge based O(n) solution to find median of
// two sorted arrays
#include <stdio.h>

/* This function returns median of ar1[] and ar2[].
Assumptions in this function:
Both ar1[] and ar2[] are sorted arrays
Both have n elements */
int getMedian(int ar1[], int ar2[], int n)
{
	int i = 0; /* Current index of i/p array ar1[] */
	int j = 0; /* Current index of i/p array ar2[] */
	int count;
	int m1 = -1, m2 = -1;

	/* Since there are 2n elements, median will be average
	of elements at index n-1 and n in the array obtained after
	merging ar1 and ar2 */
	for (count = 0; count <= n; count++)
	{
		/*Below is to handle case where all elements of ar1[] are
		smaller than smallest(or first) element of ar2[]*/
		if (i == n)
		{
			m1 = m2;
			m2 = ar2[0];
			break;
		}

		/*Below is to handle case where all elements of ar2[] are
		smaller than smallest(or first) element of ar1[]*/
		else if (j == n)
		{
			m1 = m2;
			m2 = ar1[0];
			break;
		}
		/* equals sign because if two
			arrays have some common elements */
		if (ar1[i] <= ar2[j])
		{
			m1 = m2; /* Store the prev median */
			m2 = ar1[i];
			i++;
		}
		else
		{
			m1 = m2; /* Store the prev median */
			m2 = ar2[j];
			j++;
		}
	}

	return (m1 + m2)/2;
}

/* Driver program to test above function */
int main()
{
	int ar1[] = {1, 12, 17, 26, 38};
	int ar2[] = {2, 13, 17, 30, 45};

	int n1 = sizeof(ar1)/sizeof(ar1[0]);
	int n2 = sizeof(ar2)/sizeof(ar2[0]);
	if (n1 == n2)
		printf("Median is %d", getMedian(ar1, ar2, n1));
	else
		printf("Doesn't work for arrays of unequal size");
	
	return 0;
}
